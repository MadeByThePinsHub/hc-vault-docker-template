#!/bin/bash
# shellcheck disable=SC2034,SC2155,SC1004 shell=bash

##### LICENSE #####
# MIT License
#
# Copyright (c) 2021-present Andrei Jiroh Halili, The Pins Team and its contributors
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:

# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.
##### LICENSE #####

### COPIED FROM https://github.com/hashicorp/docker-vault/blob/master/0.X/docker-entrypoint.sh - START ###

# Commit: https://github.com/hashicorp/docker-vault/commit/dfe2dcc44a0325248015bc52a4a64a96b1cae6fb

set -e

# Note above that we run dumb-init as PID 1 in order to reap zombie processes
# as well as forward signals to all processes in its session. Normally, sh
# wouldn't do either of these functions so we'd leak zombies as well as do
# unclean termination of all our sub-processes. We don't know about bash.

# Prevent core dumps
ulimit -c 0

# Allow setting VAULT_REDIRECT_ADDR and VAULT_CLUSTER_ADDR using an interface
# name instead of an IP address. The interface name is specified using
# VAULT_REDIRECT_INTERFACE and VAULT_CLUSTER_INTERFACE environment variables. If
# VAULT_*_ADDR is also set, the resulting URI will combine the protocol and port
# number with the IP of the named interface.
get_addr () {
    local if_name=$1
    local uri_template=$2
    ip addr show dev $if_name | awk -v uri=$uri_template '/\s*inet\s/ { \
      ip=gensub(/(.+)\/.+/, "\\1", "g", $2); \
      print gensub(/^(.+:\/\/).+(:.+)$/, "\\1" ip "\\2", "g", uri); \
      exit}'
}

if [ -n "$VAULT_REDIRECT_INTERFACE" ]; then
    export VAULT_REDIRECT_ADDR=$(get_addr $VAULT_REDIRECT_INTERFACE ${VAULT_REDIRECT_ADDR:-"http://0.0.0.0:8200"})
    echo "Using $VAULT_REDIRECT_INTERFACE for VAULT_REDIRECT_ADDR: $VAULT_REDIRECT_ADDR"
fi
if [ -n "$VAULT_CLUSTER_INTERFACE" ]; then
    export VAULT_CLUSTER_ADDR=$(get_addr $VAULT_CLUSTER_INTERFACE ${VAULT_CLUSTER_ADDR:-"https://0.0.0.0:8201"})
    echo "Using $VAULT_CLUSTER_INTERFACE for VAULT_CLUSTER_ADDR: $VAULT_CLUSTER_ADDR"
fi

# VAULT_CONFIG_DIR isn't exposed as a volume but you can compose additional
# config files in there if you use this image as a base, or use
# VAULT_LOCAL_CONFIG below.
VAULT_CONFIG_DIR=/vault/config

# You can also set the VAULT_LOCAL_CONFIG environment variable to pass some
# Vault configuration JSON without having to bind any volumes.
if [ -n "$VAULT_LOCAL_CONFIG" ]; then
    echo "$VAULT_LOCAL_CONFIG" > "$VAULT_CONFIG_DIR/local.json"
fi

### COPIED FROM https://github.com/hashicorp/docker-vault/blob/master/0.X/docker-entrypoint.sh - END ###

useColor() {
  # Only use colors if connected to a terminal
  if [ -t 1 ]; then
    RED=$(printf '\033[31m')
    GREEN=$(printf '\033[32m')
    YELLOW=$(printf '\033[33m')
    BLUE=$(printf '\033[34m')
    MAGENTA=$(printf '\033[35m')
    BOLD=$(printf '\033[1m')
    RESET=$(printf '\033[m')
  else
    RED=""
    GREEN=""
    YELLOW=""
    BLUE=""
    MAGENTA=""
    BOLD=""
    RESET=""
  fi
}

warn() {
  echo "${YELLOW}warning: $* ${RESET}"
}

success() {
  echo "${GREEN}success: $* ${RESET}"
}

error() {
  echo "${RED}error: $* ${RESET}"
}

echoStageName() {
  echo "${BOLD}----> $* ${RESET}"
}

extractEnvVars() {
  echoStageName "Extracting environment variables"
  if [[ $API_ADDRESS == "" ]] && [[ $VAULT_SERVER_MODE == "development" ]]; then
     export API_ADDRESS="http://localhost:3000"
  fi

  if [[ $DATABASE_URL == "" ]]; then
     warn "DATABASE_URL is undefined, falling back to Compose-styled defaults"
     export DATABASE_URL="postgres://bullshithq:shitfuckery@db/hashcorpvault_db"
     export PGUSER=bullshithq PGPASSWORD=shitfuckery PGHOST=db PGPORT=5432 PGDATABASE=hashicorpvault_db
  elif [[ $DATABASE_URL == "" ]] && [[ $PGHOST != "" && $PGPORT != "" ]]; then
     export DATABASE_URL="postgres://$PGUSER:$PGPASSWORD@$PGHOST:$PGPORT/$PGDATABASE"
  fi

  if [[ $DISABLE_MEMORY_LOCKING == "" ]]; then
     warn "Memory locking is enabled, make sure you add the IPC_LOCK cap when running this image or atleast your PaaS provider supports it."
     warn "If Vault complains about this, stop and start with DISABLE_MEMORY_LOCKING variable set to true"
     export DISABLE_MEMORY_LOCKING=false
  fi
}

runDBMigrations() {
  echoStageName "Running database migrations in 15 seconds"
  sleep 15
  if [[ $SKIP_DB_MIGRATIONS_MANUAL == "true" ]]; then
    warn "Postgres database migrations are being skipped, proceed at your own risk"
  elif [[ $PGPORT == "" ]] && [[ $PGDATABASE == "" ]]; then
    error "PGHOST and PGPORT are required for database migrations to run but found missing, aborting..."
    exit 2
  elif [[ $PGUSER == "" ]]; then
    error "PGUSER is required for database migrations to run but found missing, aborting..."
    exit 2
  elif [[ $PGDATABASE == "" ]]; then
    error "PGDATABASE is required for database migrations to run but found missing, aborting..."
    exit 2
  elif [[ $PGPASSWORD == "" ]]; then
    warn "PGPASSWORD is missing, proceed at your own risk!"
    if ! psql -h $PGHOST -p $PGPORT -U $PGUSER -d $PGDATABASE < /vault/sql-src/manual/init-db.sql; then
      error "Database migrations has failed, aborting" && exit 2
    else
      success "Database migrations successfully ran"
    fi
  else
    if ! PGPASSWORD=$PGPASSWORD psql -h $PGHOST -p $PGPORT -U $PGUSER -d $PGDATABASE < /vault/sql-src/manual/init-db.sql; then
      error "Database migrations has failed, aborting" && exit 2
    else
      success "Database migrations successfully ran"
    fi
  fi
}

startVaultServer() {
  if [[ $1 == "production" ]]; then
    # Extract env vars and do checks here
    extractEnvVars

    # Run database migrations
    runDBMigrations

    echoStageName "Generating configuration"
    envsubst < /vault/template.hcl > /vault/config/main.hcl

    echoStageName "Starting Vault server in production mode in 5 seconds"
    sleep 5
    set -- vault server -config="$VAULT_CONFIG_DIR"
  elif [[ $1 == "development" ]]; then
    warn "You're running Vault server in development mode, whoch the docs don't recommend to do in production and only for testing purposes only. Proceed at your own risk!"

    echoStageName "Starting Vault server in development mode in 5 seconds"
    sleep 5
    set -- vault server \
        -dev \
        -dev-root-token-id="$VAULT_DEV_ROOT_TOKEN_ID" \
        -dev-listen-address="${VAULT_DEV_LISTEN_ADDRESS:-"0.0.0.0:3000"}" \
        "$@"
  fi
}

# If the user is trying to run Vault directly with some arguments, then
# pass them to Vault.
if [ "${1:0:1}" = '-' ]; then
    set -- vault "$@"
fi

if [[ "$1" == "prod" ]] || [[ "$1" == "server" ]] || [[ $1 == "production" ]]; then
  shift
  startVaultServer production
elif [[ $1 == "dev" ]] || [[ $1 == "development" ]];then
  shift
  startVaultServer development
fi

exec "$@"